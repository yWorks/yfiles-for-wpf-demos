/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.6.
 ** Copyright (c) 2000-2024 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using Demo.yFiles.Toolkit;
using yWorks.Controls.Input;
using yWorks.Controls;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.Styles;
using yWorks.Graph.LabelModels;

namespace Demo.yFiles.Graph.Input.MoveUnselectedNodes
{
  /// <summary>
  /// Shows how to use and configure the <see cref="GraphEditorInputMode.MoveUnselectedInputMode"/>.
  /// </summary>
  /// <remarks>
  /// This special move input mode can be used to move nodes without selecting them first.
  /// </remarks>
  public partial class MoveUnselectedNodesWindow
  {
    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public MoveUnselectedNodesWindow() {
      InitializeComponent();
    }

    /// <summary>
    /// Initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="InitializeInputModes"/>
    /// <seealso cref="InitializeGraph"/>
    protected virtual void OnLoaded(object source, EventArgs e) {
      // initialize the graph
      InitializeGraph();

      // initialize the input mode
      InitializeInputModes();
      GraphControl.FitGraphBounds();
    }
    
    /// <summary>
    /// Creates and registers the input modes.
    /// </summary>
    protected virtual void InitializeInputModes()
    {
      var mode = new GraphEditorInputMode();

      // Always add a label to the newly created nodes
      mode.NodeCreator = (context, graph, location, parent) =>
      {
        var node = graph.CreateNode(location);
        graph.AddLabel(node, "Node");
        return node;
      };

      // The original MoveInputMode is only active when the 'Classic Mode' toggle button is checked
      mode.MoveInputMode.Enabled = btnClassic.IsChecked.Value;

      // Enable the MoveUnselectedInputMode:
      mode.MoveUnselectedInputMode.Enabled = true;
      // configure the recognizer to also respect the IsRecognized method
      mode.MoveUnselectedInputMode.PressedRecognizer = mode.MoveUnselectedInputMode.PressedRecognizer.And(IsRecognized);
      mode.MoveUnselectedInputMode.HoverRecognizer = mode.MoveUnselectedInputMode.HoverRecognizer.And(IsRecognized);

      graphControl.InputMode = mode;
    }

    /// <summary>
    /// A custom <see cref="EventRecognizer"/> to be used as modifier recognizer.
    /// </summary>
    /// <remarks>
    /// Has to return true if the move input mode is allowed to move a node.
    /// </remarks>
    private bool IsRecognized(object eventSource, EventArgs eventArg) {
      // return the value according to the Mode combo box
      switch (cmbMode.SelectedIndex) {
        case 0: // always
        case 2: // on top (this is handled by custom IHitTestable)
          // the same as the unmodified MoveUnselectedInputMode;
          return true;
        case 1: // shift is not pressed
          return !KeyEventRecognizers.ShiftPressed(eventSource, eventArg);
        case 3: // if enabled
          return btnEnable.IsChecked.Value;
        default:
          return false;
      }
    }

    /// <summary>
    /// Initializes the graph instance setting default styles
    /// and creating a small sample graph.
    /// </summary>
    protected virtual void InitializeGraph() {
      // set the default node style
      Graph.NodeDefaults.Style = new GroupNodeStyle {
          TabBrush = Themes.PaletteOrange.Fill,
          ContentAreaInsets = InsetsD.Empty
      };
      Graph.NodeDefaults.Size = new SizeD(60,80);
      Graph.NodeDefaults.Labels.LayoutParameter = new GroupNodeLabelModel().CreateTabBackgroundParameter();
      Graph.NodeDefaults.Labels.Style = new DefaultLabelStyle { TextBrush = Brushes.White };

      Graph.EdgeDefaults.Style = DemoStyles.CreateDemoEdgeStyle();

      // Create a sample node
      Graph.AddLabel(Graph.CreateNode(), "Node");
    }

    /// <summary>
    /// Returns the GraphControl instance used in the form.
    /// </summary>
    public GraphControl GraphControl {
      get { return graphControl; }
    }

    /// <summary>
    /// Gets the currently registered IGraph instance from the GraphControl.
    /// </summary>
    public IGraph Graph {
      get { return GraphControl.Graph; }
    }


    private void OnClassicClicked(object sender, RoutedEventArgs e) {
      ((GraphEditorInputMode) graphControl.InputMode).MoveInputMode.Enabled = btnClassic.IsChecked.Value;
    }

    // Called when the mode combo box has changed: 
    // if necessary it changes the hit testable for the move input mode
    private void OnMoveModeChanged(object sender, SelectionChangedEventArgs e) {
      var moveUnselectedInputMode = graphControl != null ? ((GraphEditorInputMode) graphControl.InputMode).MoveUnselectedInputMode : null;
      if (moveUnselectedInputMode == null) {
        return;
      }
      if (cmbMode.SelectedIndex == 2) {
        // mode 2 (only top region): set a custom hit testable which detects hits
        // only at the top of the nodes
        moveUnselectedInputMode.HitTestable = new TopInsetsHitTestable((GraphEditorInputMode) graphControl.InputMode);
      }
      else if (moveUnselectedInputMode.HitTestable is TopInsetsHitTestable) {
        // all other modes: if a TopInsetsHitTestable is the current hit testable
        // restore the original hit testable
        moveUnselectedInputMode.HitTestable = GraphEditorInputMode.UnselectedMovablesHitTestable;
      }
    }

    /// <summary>
    /// An IHitTestable implementation which detects hits only on top insets of a node.
    /// </summary>
    private class TopInsetsHitTestable : IHitTestable
    {
      private readonly GraphEditorInputMode inputMode;

      public TopInsetsHitTestable(GraphEditorInputMode inputMode) {
        this.inputMode = inputMode;
      }

      /// <summary>
      /// Test whether the given location is a valid hit.
      /// </summary>
      /// <remarks>
      /// The hit is considered as valid if the location lies inside a node's top insets.
      /// </remarks>
      /// <param name="context">The current input mode context.</param>
      /// <param name="location">The location to test.</param>
      /// <returns></returns>
      public bool IsHit(IInputModeContext context, PointD location) {
        // Get the current hit tester from the input mode context
        IHitTester<IModelItem> enumerator = inputMode.InputModeContext.Lookup(typeof(IHitTester<IModelItem>)) as IHitTester<IModelItem>;
        if (enumerator != null) {
          // get an enumerator over all elements at the given location
          var hits = enumerator.EnumerateHits(inputMode.InputModeContext, location);
          foreach (var item in hits) {
            // if the element is a node and its lookup returns an INodeInsetsProvider
            var node = item as INode;
            if (node != null) {
              var insetsProvider = node.Lookup<INodeInsetsProvider>();
              if (insetsProvider != null) {
                // determine whether the given location lies inside the top insets
                InsetsD insets = insetsProvider.GetInsets(node);
                if (new RectD(node.Layout.X, node.Layout.Y, node.Layout.Width, insets.Top).Contains(location)) {
                  // if so: return true
                  return true;
                }
                // else: continue iteration
              }
            }
          }
        }
        // no hits found: return false
        return false;
      }
    }
  }
}
