/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.6.
 ** Copyright (c) 2000-2024 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Globalization;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Data;
using System.Windows.Media;
using yWorks.Controls;
using yWorks.Controls.Input;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.LabelModels;
using yWorks.Graph.Styles;
using yWorks.GraphML;

namespace Demo.yFiles.Graph.BezierEdgeStyle
{
  /// <summary>
  /// Simple demo that hosts a <see cref="GraphControl"/>
  /// which enables graph editing via the default <see cref="GraphEditorInputMode"/> 
  /// input mode for editing graphs.
  /// </summary>
  /// <remarks>
  /// This demo also supports grouped graphs. Selected nodes can be grouped 
  /// in so-called group nodes using CTRL-G and again be ungrouped using CTRL-U. 
  /// To move sets of nodes into and out of group nodes using the mouse, hold down 
  /// the SHIFT key while dragging.
  /// <para>
  /// Apart from graph editing, the demo demonstrates various basic features that are already
  /// present on GraphControl (either as predefined commands or as simple method calls),
  /// for example load/save/export.
  /// </para>
  /// <para>
  /// In addition to the GraphControl itself, the demo also shows how to use the GraphOverviewControl.
  /// </para>
  /// </remarks>
  public partial class BezierEdgeStyleWindow
  {
    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public BezierEdgeStyleWindow() {
      SmoothEditing = true;
      bezierEdgeSegmentLabelModel = new BezierEdgeSegmentLabelModel();
      bezierPathLabelModel = new BezierEdgePathLabelModel();
      Angle = 0;
      AutoRotation = true;
      AutoSnapping = true;
      EnableEditing = true;
      InitializeComponent();
    }

    /// <summary>
    /// Initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="InitializeGraph"/>
    protected virtual void OnLoaded(object source, EventArgs e) {
      // Set a custom visual creator for the overview so BÃ©zier edges get rendered
      Overview.GraphVisualCreator = new BezierOverviewVisualCreator(Overview.Graph);

      // initialize the graph
      InitializeGraph();

      // initialize the input mode
      graphControl.InputMode = CreateEditorMode();

      LoadSampleGraph();
    }

    /// <summary>
    /// Creates the default input mode for the GraphControl, a <see cref="GraphEditorInputMode" />.
    /// </summary>
    /// <returns>a new GraphEditorInputMode instance and configures snapping and orthogonal edge editing</returns>
    protected virtual IInputMode CreateEditorMode() {
      var graphEditorInputMode = new BezierGraphEditorInputMode(this);

      return graphEditorInputMode;
    }
    
    /// <summary>
    /// Initializes the graph instance setting default styles
    /// and creating a small sample graph.
    /// </summary>
    protected virtual void InitializeGraph() {
      Graph.SetUndoEngineEnabled(true);

      //We need to provide our own handles for bezier edge bends:
      RegisterBezierDecorators();

      //Trigger re-evaluation of handles remove stale handles
      Graph.BendRemoved += delegate { RequeryHandles(); };
      Graph.BendAdded += delegate { RequeryHandles(); };

      Graph.NodeDefaults.Style = new ShapeNodeStyle { Brush = Brushes.LightGray, Shape = ShapeNodeShape.Ellipse, Pen = null};
      Graph.EdgeDefaults.Style = bezierEdgeStyle;
      Graph.EdgeDefaults.Labels.Style = new DefaultLabelStyle {
          BackgroundBrush = Brushes.White,
          BackgroundPen = new Pen(new SolidColorBrush(Color.FromRgb(0xff, 0xa5, 0x00)), 1),
          Insets = new InsetsD(3),
          TextAlignment = TextAlignment.Center
      };
      Graph.EdgeDefaults.Labels.LayoutParameter = bezierPathLabelModel.CreateDefaultParameter();
    }

    private void LoadSampleGraph() {
      //Always use shared references for the sample graphs
      GraphControl.GraphMLIOHandler.ResolveReference += delegate(object sender, ResolveReferenceEventArgs args) {
        switch (args.ReferenceId) {
          case "bezierPathLabelModel":
            args.Value = bezierPathLabelModel;
            break;
          case "bezierSegmentLabelModel":
            args.Value = bezierEdgeSegmentLabelModel;
            break;
          default:
            break;
        }
      };

      GraphControl.ImportFromGraphML("Resources\\SampleCircle.graphml");

      GraphControl.FitGraphBounds();
    }

    private void RegisterBezierDecorators() {
      Graph.GetDecorator().BendDecorator.HandleDecorator.HideImplementation(
          b => !EnableEditing && b.Owner.Style is yWorks.Graph.Styles.BezierEdgeStyle && b.Owner.Bends.Count % 3 == 2);

      Graph.GetDecorator().BendDecorator.HandleDecorator.SetImplementationWrapper(
          b => EnableEditing && SmoothEditing && b.Owner.Style is yWorks.Graph.Styles.BezierEdgeStyle && b.Owner.Bends.Count % 3 == 2,
          delegate(IBend b, IHandle h) {
            var index = b.GetIndex();
            switch (index % 3) {
              case 0:
              case 1:
                //Handle for the first control point of a triple
                return new OuterControlPointHandle(h, b);
              case 2:
              default:
                //The "middle" control point controls the previous and next ones
                return new InnerControlPointHandle(h, b);
            }
          });

      //Override the default for bezier edges
      Graph.GetDecorator().EdgeDecorator.BendCreatorDecorator.SetImplementation(
          edge => EnableEditing && edge.Style is yWorks.Graph.Styles.BezierEdgeStyle,
          new BezierBendCreator());

      //And always show bend handles
      Graph.GetDecorator().EdgeDecorator.HandleProviderDecorator.SetImplementationWrapper(edge => EnableEditing && edge.Style is yWorks.Graph.Styles.BezierEdgeStyle,
          (edge, coreImpl) => new BezierEdgeHandleProvider(edge, coreImpl));

      Graph.GetDecorator().EdgeDecorator.SelectionDecorator.SetImplementationWrapper(e => e.Style is yWorks.Graph.Styles.BezierEdgeStyle,
          (e, coreImpl) => new BezierSelectionIndicatorInstaller(coreImpl));
    }


    private void RequeryHandles() {
      if (graphControl.InputMode != null) {
        ((GraphEditorInputMode) graphControl.InputMode).RequeryHandles();
      }
    }
    private static readonly yWorks.Graph.Styles.BezierEdgeStyle bezierEdgeStyle =
        new yWorks.Graph.Styles.BezierEdgeStyle {
            Pen = (Pen) new Pen(new SolidColorBrush(Color.FromRgb(0x41, 0x69, 0xe1)), 3).GetAsFrozen(),
            TargetArrow = new Arrow(Color.FromRgb(0x41, 0x69, 0xe1)) { Type = ArrowType.Triangle }
        };

    private bool smoothEditing;
    private readonly BezierEdgeSegmentLabelModel bezierEdgeSegmentLabelModel;
    private readonly BezierEdgePathLabelModel bezierPathLabelModel;
    private bool autoRotation;
    private double angle;
    private bool autoSnapping;
    private bool enableEditing;

    public bool SmoothEditing {
      get { return smoothEditing; }
      set {
        smoothEditing = value;
        if (GraphControl != null) {
          var geim = GraphControl.InputMode as GraphEditorInputMode;
          if (geim != null) {
            var bceim = geim.CreateEdgeInputMode as BezierCreateEdgeInputMode;
            if (bceim != null) {
              bceim.CreateSmoothSplines = value;
            }
            geim.RequeryHandles();
          }
        }
      }
    }

    /// <summary>
    /// Returns the GraphControl instance used in the form.
    /// </summary>
    public GraphControl GraphControl {
      get { return graphControl; }
    }

    /// <summary>
    /// Gets the currently registered IGraph instance from the GraphControl.
    /// </summary>
    public IGraph Graph {
      get { return GraphControl.Graph; }
    }

    public bool AutoRotation {
      get { return autoRotation; }
      set {
        if (autoRotation != value) {
          autoRotation = value;
          bezierEdgeSegmentLabelModel.AutoRotation = value;
          bezierPathLabelModel.AutoRotation = value;
          if (GraphControl != null) {
            GraphControl.UpdateVisual();
          }
        }
      }
    }

    public bool AutoSnapping {
      get { return autoSnapping; }
      set {
        if (autoSnapping != value) {
          autoSnapping = value;
          bezierEdgeSegmentLabelModel.AutoSnapping = value;
          bezierPathLabelModel.AutoSnapping = value;
          if (GraphControl != null) {
            GraphControl.UpdateVisual();
          }
        }
      }
    }
    public double Angle {
      get { return angle; }
      set {
        if (angle != value) {
          angle = value;
          bezierEdgeSegmentLabelModel.Angle = Math.PI * angle / 180.0;
          bezierPathLabelModel.Angle = Math.PI * angle / 180.0;
          if (GraphControl != null) {
            GraphControl.UpdateVisual();
          }
        }
      }
    }

    public bool EnableEditing {
      get { return enableEditing; }
      set {
        if (enableEditing != value) {
          enableEditing = value;
          if (GraphControl != null) {
            var geim = GraphControl.InputMode as GraphEditorInputMode;
            if (geim != null) {
              geim.RequeryHandles();
            }
          }
        }
      }
    }

    private void exitToolStripMenuItem_Click(object sender, EventArgs e) {
      Application.Current.Shutdown();
    }

    private void newButton_Click(object sender, EventArgs e) {
      graphControl.Graph.Clear();
    }

    private void OnSampleChanged(object sender, SelectionChangedEventArgs e) {
      if (GraphControl != null) {
        switch (sampleGraphs.SelectedItem) {
          case "Circular Layout":
            GraphControl.ImportFromGraphML("Resources\\SampleCircle.graphml");
            break;
          case "Graph with Labels":
            GraphControl.ImportFromGraphML("Resources\\SampleLabels.graphml");
            break;
        }
      }
    }
  }

  [ValueConversion(typeof(double), typeof(string))]
  public class DoubleConverter : IValueConverter
  {
    public object Convert(object value, Type targetType, object parameter, CultureInfo culture) {
      double doubleType = (double) value;
      return doubleType.ToString();
    }

    public object ConvertBack(object value, Type targetType, object parameter, CultureInfo culture) {
      string strValue = value as string;
      double resultDouble;
      if (double.TryParse(strValue, out resultDouble)) {
        return resultDouble;
      }
      return DependencyProperty.UnsetValue;
    }
  }
}
