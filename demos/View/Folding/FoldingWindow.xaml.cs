/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.5.
 ** Copyright (c) 2000-2022 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Collections.Generic;
using System.ComponentModel;
using System.IO;
using System.Windows;
using System.Windows.Input;
using System.Windows.Media;
using Demo.yFiles.Toolkit;
using yWorks.Controls;
using yWorks.Controls.Input;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.Styles;

namespace Demo.yFiles.Graph.Folding
{
  /// <summary>
  /// Simple Form that hosts a <see cref="GraphControl"/>
  /// which demonstrates the power of the <see cref="FoldingManager"/>
  /// for working with grouped graphs and collapsing/expanding group node
  /// contents.
  /// </summary>
  /// <remarks>
  /// This demo supports folding operations, i.e., selected group nodes can be expanded
  /// using CTRL-ADD, and again be collapsed using CTRL-SUBTRACT. 
  /// Use CTRL-PageDown to enter a group node and CTRL-PageUp to exit the current group node.
  /// </remarks>
  public partial class FoldingWindow
  {
    /// <summary>
    /// Defines the command that is used by the Window to <see cref="ShowContents">show the contents</see>
    /// of a group node in a separate window.
    /// </summary>
    public static readonly ICommand ShowContentsCommand = new RoutedUICommand("Show Contents", "ShowContents", typeof(FoldingWindow));

    private FoldingManager foldingManager;

    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public FoldingWindow() {
      InitializeComponent();
    }

    /// <summary>
    /// Initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="InitializeInputModes"/>
    /// <seealso cref="InitializeGraph"/>
    private void OnLoaded(object sender, EventArgs routedEventArgs) {
      // initialize the graph
      InitializeGraph();

      // initialize the input mode
      InitializeInputModes();
      graphControl.FitGraphBounds();
    }

    /// <summary>
    /// Calls <see cref="CreateEditorMode"/> and registers
    /// the result as the <see cref="CanvasControl.InputMode"/>.
    /// </summary>
    protected virtual void InitializeInputModes() {
      graphControl.InputMode = CreateEditorMode();
    }

    /// <summary>
    /// Creates the default input mode for the GraphControl,
    /// a <see cref="GraphEditorInputMode"/>.
    /// </summary>
    /// <returns>a new GraphEditorInputMode instance</returns>
    protected virtual IInputMode CreateEditorMode() {
      return new GraphEditorInputMode() {AllowGroupingOperations = true};
    }

    /// <summary>
    /// Initializes the graph instance setting default styles
    /// and creating a small sample graph.
    /// </summary>
    protected virtual void InitializeGraph() {

      // Create the folding manager
      foldingManager = new FoldingManager();
      
      // initialize it with some default for this demo.
      InitializeFoldingManager();

      // initialize the master graph
      DemoStyles.InitDemoStyles(foldingManager.MasterGraph, foldingEnabled: true);

      // enable undoability on the master graph
      foldingManager.MasterGraph.SetUndoEngineEnabled(true);

      // create a managed view
      IFoldingView view = foldingManager.CreateFoldingView();
      view.EnqueueNavigationalUndoUnits = true;

      // and display it
      graphControl.Graph = view.Graph;

      IGraph graph = foldingManager.MasterGraph;

      // try loading the initial sample graph
      try {
        string s = Environment.CurrentDirectory;
        graphControl.ImportFromGraphML(new FileInfo(s + "\\sample.graphml"));
      } catch (IOException) {
        // create initial sample data in our model
        CreateInitialModelGraph(graph);
      }
    }

    /// <summary>
    /// Creates the initial graph in the model.
    /// </summary>
    /// <param name="graph">The model graph.</param>
    private void CreateInitialModelGraph(IGraph graph) {
      // create some nodes and groups
      INode g0 = graph.CreateGroupNode();
      INode g1 = graph.CreateGroupNode(g0);
      INode c1 = graph.CreateNode(g0);
      INode c2 = graph.CreateNode(g0);
      INode c3 = graph.CreateNode(g1);
      INode c0 = graph.CreateNode();

      // create some edges
      graph.CreateEdge(c1, c2);
      graph.CreateEdge(c0, g0);
      graph.CreateEdge(c0, c1);
      graph.CreateEdge(c2, c0);
      graph.CreateEdge(c2, c3);
      graph.CreateEdge(g1, c0);

    }

    /// <summary>
    /// Initializes the folding manager.
    /// </summary>
    private void InitializeFoldingManager() {
      // configure our way of displaying collapsed group nodes
      DefaultFolderNodeConverter folderNodeConverter = new DefaultFolderNodeConverter();
      // and another initial size
      folderNodeConverter.FolderNodeSize = new MutableSize(40, 40);
      // register the converter
      foldingManager.FolderNodeConverter = folderNodeConverter;

      // configure our way of converting edges to folding edges once they connect to collapsed group nodes
      DefaultFoldingEdgeConverter foldingEdgeConverter = new DefaultFoldingEdgeConverter();
      // we want to indicate dummy source ports using a different style
      foldingEdgeConverter.SourcePortStyle = new NodeStylePortStyleAdapter(new ShapeNodeStyle { Shape = ShapeNodeShape.Ellipse, Brush = new SolidColorBrush(Color.FromArgb(127, 0, 255, 0)), Pen = null }) { RenderSize = new SizeD(3, 3) };
      // and also dummy target ports
      foldingEdgeConverter.TargetPortStyle = new NodeStylePortStyleAdapter(new ShapeNodeStyle { Shape = ShapeNodeShape.Ellipse, Brush = new SolidColorBrush(Color.FromArgb(127, 0, 255, 0)), Pen = null }) { RenderSize = new SizeD(3, 3) };
      // also folding edges should look differently
      foldingEdgeConverter.FoldingEdgeStyle = new PolylineEdgeStyle { Pen = Pens.Red };
      // finally register the converter
      foldingManager.FoldingEdgeConverter = foldingEdgeConverter;
    }


    /// <summary>
    /// Gets the currently registered IGraph instance from the GraphControl.
    /// </summary>
    public IGraph Graph {
      get { return graphControl.Graph; }
    }

    private void ShowContents(INode localRoot) {
      Window window = new Window();
      window.Title = "Contents of " + localRoot;
      // we create a new control
      GraphControl groupContentsGraphControl = new GraphControl();

      // now obtain a view for the given node from the manager
      IFoldingView foldingView = foldingManager.CreateFoldingView(localRoot);
      // instead of switching to the ancestor if the localRoot is removed from the graph,
      // we want to dispose the window, instead.
      foldingView.AutoSwitchToAncestor = false;

      // assign the graph and input mode
      groupContentsGraphControl.Graph = foldingView.Graph;
      groupContentsGraphControl.InputMode = CreateEditorMode();
      // share the clipboard so that we can cut and copy between the windows
      groupContentsGraphControl.Clipboard = this.graphControl.Clipboard;

      // show the window
      window.Content = groupContentsGraphControl;
      window.Width = window.Height = 300;
      window.Owner = this;
      window.Show();

      // and fit the bounds
      window.Dispatcher.BeginInvoke(new Action(() => groupContentsGraphControl.FitGraphBounds()));

      // register a delegate that will dispose the window when the view gets invalid
      foldingView.PropertyChanged += delegate(object sender, PropertyChangedEventArgs e) {
        if (e.PropertyName == "Invalid" && foldingView.Invalid) {
          window.Close();
        }
      };
    }


    /// <summary>
    /// Helper method for the <see cref="ShowContentsCommand"/> binding.
    /// </summary>
    private void OnShowContentsExecuted(object sender, ExecutedRoutedEventArgs e) {
      if (graphControl == null) {
        e.Handled = false;
        return;
      }
      // get the IFoldingView instance
      IFoldingView graph = graphControl.Graph.Lookup<IFoldingView>();
      if (graph != null) {
        // find the node to show the contents for
        INode node = FindNode(graph, e.Parameter);
        // if we found one
        if (node != null) {
          // show it
          ShowContents(graph.GetMasterItem(node));
          e.Handled = true;
        }
      } else {
        e.Handled = false;
      }
    }


    /// <summary>
    /// Helper method for the <see cref="ShowContentsCommand"/> binding.
    /// </summary>
    private void OnCanShowContentsExecuted(object sender, CanExecuteRoutedEventArgs e) {
      if (graphControl == null) {
        e.Handled = false;
        return;
      }
      // see if we can execute the command...
      IFoldingView graph = graphControl.Graph.Lookup<IFoldingView>();
      if (graph != null) {
        INode node = FindNode(graph, e.Parameter);
        if (node != null) {
          // yes, we found a node - notify the binding.
          e.CanExecute = true;
          e.Handled = true;
        }
      } else {
        e.Handled = false;
      }
    }

    /// <summary>
    /// Helper method that identifies the node to show the contents of
    /// if <see cref="ShowContentsCommand"/> is executed.
    /// </summary>
    /// <remarks>
    /// This method will use the parameter as the return value or the currently selected node
    /// if it's a group node.
    /// </remarks>
    private INode FindNode(IFoldingView foldingView, object parameter) {
      INode node = parameter as INode;
      if (node != null && foldingView.Graph.Contains(node) && !foldingView.Manager.MasterGraph.IsGroupNode(foldingView.GetMasterItem(node))) {
        node = null;
      }
      if (node == null) {
        IEnumerator<INode> selectedNodes = graphControl.Selection.SelectedNodes.GetEnumerator();
        while (selectedNodes.MoveNext()) {
          node = selectedNodes.Current;
          if (foldingView.Graph.Contains(node) && foldingView.Manager.MasterGraph.IsGroupNode(foldingView.GetMasterItem(node))) {
            break;
          } else {
            node = null;
          }
        }
      }
      return node;
    }

    private void showModelToolStripMenuItem_Click(object sender, EventArgs e) {
      Window window = new Window();
      window.Title = "Model";
      GraphControl control = new GraphControl();
      // show the master graph
      control.Graph = foldingManager.MasterGraph;
      control.InputMode = CreateEditorMode();

      window.Content = control;
      window.Width = window.Height = 300;
      window.Owner = this;
      window.Show();

      control.FitGraphBounds();
    }

    private void separateFoldingEdgesToolStripMenuItem_Click(object sender, EventArgs e) {
      // show the view with default settings
      ShowAdditionalManager(new DefaultFoldingEdgeConverter());
    }

    private void excludeFoldingEdgesToolStripMenuItem_Click(object sender, EventArgs e) {
      // show the view without folding edges
      ShowAdditionalManager(new ExcludingFoldingEdgeConverter());
    }

    private void mergeFoldingEdgesToolStripMenuItem_Click(object sender, EventArgs e) {
      // show the view with merged folding edges, but consider edges directed
      MergingFoldingEdgeConverter mergingFoldingEdgeConverter = new MergingFoldingEdgeConverter();
      mergingFoldingEdgeConverter.IgnoreEdgeDirection = false;

      ShowAdditionalManager(mergingFoldingEdgeConverter);
    }

    private void mergeUndirectedFoldingEdgesToolStripMenuItem_Click(object sender, EventArgs e) {
      // show the view with merged folding edges
      MergingFoldingEdgeConverter mergingFoldingEdgeConverter = new MergingFoldingEdgeConverter();
      mergingFoldingEdgeConverter.IgnoreEdgeDirection = true;

      ShowAdditionalManager(mergingFoldingEdgeConverter);
    }

    /// <summary>
    /// Helper method that creates a window that displays an alternative view of the
    /// MasterGraph using a separate FoldingManager and therefore a separate set of 
    /// dummy items.
    /// </summary>
    /// <remarks>
    /// This allows for using different visualizations of the folding edges and collapsed group nodes.
    /// </remarks>
    /// <param name="foldingEdgeConverter">The edge converter to use</param>
    private void ShowAdditionalManager(IFoldingEdgeConverter foldingEdgeConverter) {
      // create the window
      Window window = new Window();
      window.Title = "Separate FoldingManager using " + foldingEdgeConverter;

      // create the GraphControl
      GraphControl graphControl = new GraphControl();

      // create a new manager for the same master graph.
      FoldingManager manager = new FoldingManager(foldingManager.MasterGraph);

      // assign the provided converter
      manager.FoldingEdgeConverter = foldingEdgeConverter;

      // create a view
      IFoldingView foldingView = manager.CreateFoldingView();

      // make the view disappear once it becomes invalid
      foldingView.AutoSwitchToAncestor = false;
      // set the graph
      graphControl.Graph = foldingView.Graph;
      // and edit mode
      graphControl.InputMode = CreateEditorMode();
      // share the clipboard with the rest of the windows
      graphControl.Clipboard = this.graphControl.Clipboard;

      // show the window
      window.Content = graphControl;
      window.Width = window.Height = 300;
      window.Owner = this;
      window.Show();

      // fit the bounds 
      graphControl.FitGraphBounds();

      // setup delegate to dispose the window once the view becomes invalid
      foldingView.PropertyChanged += delegate(object _sender, PropertyChangedEventArgs _e) {
        if (_e.PropertyName == "Invalid" && foldingView.Invalid) {
          manager.Dispose();
          window.Close();
        }
      };
    }

    /// <summary>
    /// Callback action that is triggered when the user exits the application.    /// </summary>    protected virtual void exitToolStripMenuItem_Click(object sender, EventArgs e) {
      Application.Current.Shutdown();    }
  }
}
