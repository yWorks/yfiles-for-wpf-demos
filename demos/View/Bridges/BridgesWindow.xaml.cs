/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.2.
 ** Copyright (c) 2000-2019 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.ComponentModel;
using System.Windows;
using System.Windows.Controls;
using System.Windows.Media;
using yWorks.Controls;
using yWorks.Controls.Input;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.Styles;
using yWorks.Graph.LabelModels;

namespace Demo.yFiles.Graph.Bridges
{
  /// <summary>
  /// This demo shows how to use class <see cref="BridgeManager"/> to create bridges when edges cross obstacles.
  /// </summary>
  /// <remarks>In addition to bridges for edge-edge intersections, this demo shows bridges for other obstacles
  /// like group node boundaries as well.
  /// </remarks>
  public partial class BridgesWindow
  {
    private BridgeManager bridgeManager;

    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public BridgesWindow() {
      InitializeComponent();
    }


    /// <summary>
    /// Called upon loading of the form.
    /// This method initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="ConfigureBridges"/>
    /// <seealso cref="InitializeGraph"/>
    protected virtual void OnLoad(object src, EventArgs e) {

      graphControl.Graph.NodeDefaults.Style = new BevelNodeStyle { Color = Colors.Orange };
      PanelNodeStyle style = new PanelNodeStyle {Color = Colors.LightBlue, Insets = new InsetsD(20, 40, 20, 20)};
      graphControl.Graph.GroupNodeDefaults.Style = style;

      //Draw edges in front, so that group nodes don't hide the bridges...
      graphControl.GraphModelManager.EdgeGroup.ToFront();
      graphControl.GraphModelManager.HierarchicNestingPolicy = HierarchicNestingPolicy.Nodes;

      InitializeGraph(graphControl.Graph);

      ConfigureBridges();

      graphControl.InputMode = new GraphEditorInputMode{AllowGroupingOperations = true};
    }

    /// <summary>
    /// Adds and configures the <see cref="BridgeManager"/>.
    /// </summary>
    private void ConfigureBridges() {
      bridgeManager = new BridgeManager();

      // we would like to change the custom bridge rendering default, 
      // this can be done by decorating the existing default bridge creator
      bridgeManager.DefaultBridgeCreator = new CustomBridgeCreator(bridgeManager.DefaultBridgeCreator);

      //Convenience class that just queries all model item
      GraphObstacleProvider provider = new GraphObstacleProvider();

      //We also want to query nodes for potential obstacles (disabled by default)
      provider.QueryNodes = true;
      //Register an IObstacleProvider, bridgeManager will query all registered obstacle providers
      //to determine if a bridge must be created
      bridgeManager.AddObstacleProvider(provider);
      //Bind the bridge manager to the GraphControl...
      bridgeManager.CanvasControl = graphControl;
      //We register a custom obstacle provider in the node's lookup of group nodes
      // that can be used by bridgeManager (through provider...)
      graphControl.Graph.GetDecorator().NodeDecorator.ObstacleProviderDecorator.SetFactory(
        node => graphControl.Graph.IsGroupNode(node), node => new GroupNodeObstacleProvider(node));

      // Initialize GUI components that configure bridge appearance
      crossingStyleComboBox.ItemsSource = Enum.GetValues(typeof (BridgeCrossingStyle));
      crossingStyleComboBox.SelectedItem = bridgeManager.DefaultBridgeCrossingStyle;

      crossingPolicyComboBox.ItemsSource = Enum.GetValues(typeof (BridgeCrossingPolicy));
      crossingPolicyComboBox.SelectedItem = bridgeManager.BridgeCrossingPolicy;

      bridgeOrientationComboBox.ItemsSource = Enum.GetValues(typeof (BridgeOrientationStyle));
      bridgeOrientationComboBox.SelectedItem = bridgeManager.DefaultBridgeOrientationStyle;

      heightTextBox.Text = bridgeManager.DefaultBridgeHeight.ToString();
      widthTextBox.Text = bridgeManager.DefaultBridgeWidth.ToString();
    }

    /// <summary>
    /// A custom delegating bridge creator that implements <see cref="CreateCustomBridge"/> differently.
    /// </summary>
    private class CustomBridgeCreator : IBridgeCreator
    {
      private readonly IBridgeCreator fallback;

      public CustomBridgeCreator(IBridgeCreator fallback) {
        this.fallback = fallback;
      }

      public BridgeCrossingStyle GetCrossingStyle(IRenderContext context) {
        return fallback.GetCrossingStyle(context);
      }

      public BridgeOrientationStyle GetOrientationStyle(IRenderContext context) {
        return fallback.GetOrientationStyle(context);
      }

      public double GetBridgeWidth(IRenderContext context) {
        return fallback.GetBridgeWidth(context);
      }

      public double GetBridgeHeight(IRenderContext context) {
        return fallback.GetBridgeHeight(context);
      }

      public void CreateCustomBridge(IRenderContext context, GeneralPath path, PointD start, PointD end, double gapLength) {
        // first finish the last segment
        path.LineTo(start);
        // then calculate the gap
        var vectorLength = gapLength;
        if (vectorLength > 1) {
          // some helper vectors first
          var delta = end - start;
          var rightVector = delta / vectorLength;
          var upVector = new PointD(rightVector.Y, -rightVector.X);

          // get the height from the context
          double height = GetBridgeHeight(context);
          // determine bending for our arc
          double arc = 3;
          // now draw two arcs at the end and the start of the segment
          path.MoveTo(start + upVector * height - rightVector * arc);
          path.QuadTo(start + rightVector * arc, start + upVector * -height - rightVector * arc);
          path.MoveTo(end + rightVector * arc + upVector * height);
          path.QuadTo(end - rightVector * arc, end + upVector * -height + rightVector * arc);
          // finally make sure that the edge continues at the right location
          path.MoveTo(end);
        } else {
          // for very short gaps, we use a trivial rendering
          path.LineTo(start);
          path.MoveTo(end);
        }
      }
    }

    /// <summary>
    /// Change the default bridge height.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void heightTextBox_Validated(object sender, EventArgs e) {
      string s = ((TextBox) sender).Text;
      double d;
      bool cancel = !Double.TryParse(s, out d);
      if (!cancel) {
        bridgeManager.DefaultBridgeHeight = d;
        graphControl.Invalidate();
      }
    }

    /// <summary>
    /// Change the default bridge width.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void widthTextBox_Validated(object sender, EventArgs e) {
      string s = ((TextBox)sender).Text;
      double d;
      bool cancel = !Double.TryParse(s, out d);
      if (!cancel) {
        bridgeManager.DefaultBridgeWidth = d;
        graphControl.Invalidate();
      }
    }

    private void textBox_Validating(object sender, CancelEventArgs e) {
      string s = ((TextBox)sender).Text;
      double d;
      bool cancel = !Double.TryParse(s, out d);
      e.Cancel = cancel;
      if (cancel) {
        MessageBox.Show("Please enter a double value", "Invalid Argument", MessageBoxButton.OK, MessageBoxImage.Error);
      }
    }

    /// <summary>
    /// Change the default orientation style.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void bridgeOrientationComboBox_SelectedIndexChanged(object sender, EventArgs e) {
      BridgeOrientationStyle v = (BridgeOrientationStyle) bridgeOrientationComboBox.SelectedItem;
      bridgeManager.DefaultBridgeOrientationStyle = v;
      graphControl.Invalidate();
    }

    /// <summary>
    /// Change the default crossing policy.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void crossingPolicyComboBox_SelectedIndexChanged(object sender, EventArgs e) {
      BridgeCrossingPolicy v = (BridgeCrossingPolicy) crossingPolicyComboBox.SelectedItem;
      bridgeManager.BridgeCrossingPolicy = v;
      graphControl.Invalidate();
    }

    /// <summary>
    /// Change the default crossing style.
    /// </summary>
    /// <param name="sender"></param>
    /// <param name="e"></param>
    private void crossingStyleComboBox_SelectedIndexChanged(object sender, EventArgs e) {
      BridgeCrossingStyle v = (BridgeCrossingStyle) crossingStyleComboBox.SelectedItem;
      bridgeManager.DefaultBridgeCrossingStyle = v;
      graphControl.Invalidate();
    }


    /// <summary>
    /// Create a sample graph with edge/edge intersections and edge/group node intersections
    /// </summary>
    /// <param name="graph"></param>
    private void InitializeGraph(IGraph graph) {
      INode[] nodes = new INode[16];
      int count = 0;
      for (int i = 1; i < 5; i++) {
        nodes[count++] = graph.CreateNode(new PointD(50 + 40*i, 260));
        nodes[count++] = graph.CreateNode(new PointD(50 + 40*i, 40));
        nodes[count++] = graph.CreateNode(new PointD(40, 50 + 40*i));
        nodes[count++] = graph.CreateNode(new PointD(260, 50 + 40*i));
      }

      for (int i = 0; i < nodes.Length; i++) {
        graph.AddLabel(nodes[i], "" + i);
      }

      graph.CreateEdge(nodes[0], nodes[1]);

      IPort p1 = graph.AddPort(nodes[0], new PointD(0, 0));
      graph.SetRelativePortLocation(p1, new PointD(5, 0));

      IPort p2 = graph.AddPort(nodes[1], new PointD(0, 0));
      graph.SetRelativePortLocation(p2, new PointD(5, 0));
      graph.CreateEdge(p1, p2);

      graph.CreateEdge(nodes[5], nodes[4]);

      graph.CreateEdge(nodes[2], nodes[3]);

      graph.CreateEdge(nodes[7], nodes[6]);

      graph.CreateEdge(nodes[2 + 8], nodes[3 + 8]);
      graph.CreateEdge(nodes[7 + 8], nodes[6 + 8]);

      graph.CreateEdge(nodes[0 + 8], nodes[1 + 8]);
      graph.CreateEdge(nodes[5 + 8], nodes[4 + 8]);

      INode n1 = graph.CreateNode(new PointD(300, 150));
      INode n2 = graph.CreateNode(new PointD(400, 150));
      INode n3 = graph.CreateNode(new PointD(500, 150));

      graph.CreateEdge(n1, n3);
      INode groupNode = graph.CreateGroupNode();
      graph.AddLabel(groupNode, "Group Node", InteriorStretchLabelModel.North);
      graph.SetParent(n2, groupNode);
      graph.AdjustGroupNodeLayout(groupNode);

      graphControl.UpdateContentRect();
    }

    /// <summary>
    /// Custom <see cref="IObstacleProvider"/> implementation that returns the node style's outline
    /// as an obstacle.
    /// </summary>
    /// <seealso cref="IShapeGeometry.GetOutline"/>
    private class GroupNodeObstacleProvider : IObstacleProvider
    {
      private readonly INode groupNode;

      public GroupNodeObstacleProvider(INode groupNode) {
        this.groupNode = groupNode;
      }

      /// <summary>
      /// Return an obstacle for the node style's outline.
      /// </summary>
      /// <param name="context"></param>
      /// <returns></returns>
      public GeneralPath GetObstacles(IRenderContext context) {
        INodeStyle style = groupNode.Style;
        bool visible = style.Renderer.GetVisibilityTestable(groupNode, style).IsVisible(context, context.Clip);
        if (!visible) {
          //If the node is invisible, don't return anything (won't be painted anyway...)
          return null;
        } else {
          //Otherwise, creta an obstacle
          return CreatePath();
        }
      }

      /// <summary>
      /// Use the node style's outline as obstacle.
      /// </summary>
      /// <remarks>For node style renderers that don't provide a <see cref="IShapeGeometry"/>, no bridges will be created.</remarks>
      /// <returns></returns>
      private GeneralPath CreatePath() {
        INodeStyle style = groupNode.Style;
        IShapeGeometry geometry = style.Renderer.GetShapeGeometry(groupNode, style);
        if (geometry != null) {
          GeneralPath outline = geometry.GetOutline();
          return outline;
        }
        return null;
      }
    }

    #region Standard Actions

    /// <summary>
    /// Callback action that is triggered when the user exits the application.
    /// </summary>
    protected virtual void exitAction(object sender, EventArgs e) {
      Application.Current.Shutdown();
    }

    #endregion
  }
}
