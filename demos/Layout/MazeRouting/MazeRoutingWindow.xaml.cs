/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.6.
 ** Copyright (c) 2000-2024 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading.Tasks;
using System.Windows;
using System.Windows.Media;
using Demo.yFiles.Toolkit;
using yWorks.Controls;
using yWorks.Controls.Input;
using yWorks.Graph;
using yWorks.Graph.Styles;
using yWorks.Layout;
using yWorks.Layout.Router;
using yWorks.Layout.Router.Polyline;
using yWorks.Utils;

namespace Demo.yFiles.Layout.MazeRouting
{
  /// <summary>
  /// Maze Routing demo that hosts a <see cref="GraphControl"/>, and an option view
  /// to adjust the settings of the used Edge Routing Algorithm.
  /// </summary>
  public partial class MazeRoutingWindow
  {
    // the graph with maze nodes to run the algorithm on
    private IGraph fullGraph;

    // the config for the algorithm
    private PolylineEdgeRouterCustomConfig edgeRouterConfig;

    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components, adds a 
    /// <see cref="GraphControl"/> to the form,
    /// and displays settings for the config of the edgeRouter.
    /// </summary>
    public MazeRoutingWindow() {
      InitializeComponent();

      // initialise a new config
      edgeRouterConfig = new PolylineEdgeRouterCustomConfig();

      // display the config in the UI
      Editor.Configuration = edgeRouterConfig;
    }

    /// <summary>
    /// Initializes the graph and the input mode.
    /// </summary>
    /// <seealso cref="InitializeGraph"/>
    protected virtual void OnLoaded(object source, EventArgs e) {
      // initialize the graph
      InitializeGraph();

      // initialize the input mode
      CreateEditorInputMode();

      graphControl.FitGraphBounds();
    }

    /// <summary>
    /// Called when an edge has been created interactively.
    /// </summary>
    private async void EdgeCreatedListener(object sender, ItemEventArgs<IEdge> args) {
      var addedEdge = args.Item;
      await RouteAffectedEdges(new List<IEdge> { addedEdge });
    }

    /// <summary>
    /// Called when an drag gesture has been finished, re-route edges according to
    /// current selection
    /// </summary>
    private async void DragFinishedListenerMove(object sender, InputModeEventArgs e) {
      var graphSelection = graphControl.Selection;
      var selectedNodes = graphSelection.SelectedNodes.ToList();
      var selectedEdges = graphSelection.SelectedEdges.ToList();

      if (graphSelection.Count == graphSelection.SelectedNodes.Count) {
        // only nodes are selected
        await RouteAffectedEdges(GetAffectedEdges(selectedNodes));
      } else if (graphSelection.Count == graphSelection.SelectedEdges.Count) {
        // only edges are selected
        await RouteAffectedEdges(selectedEdges);
      } else {
        // both are selected

        // merge selected nodes and edges
        selectedEdges.AddRange(GetAffectedEdges(selectedNodes));

        // route the affected edges
        await RouteAffectedEdges(selectedEdges);
      }
    }

    /// <summary>
    /// Gets a list of nodes and returns all edges
    /// that start or end at one of the nodes in a list
    /// </summary>
    private IEnumerable<IEdge> GetAffectedEdges(List<INode> nodes) {
      return nodes.SelectMany(n => Graph.EdgesAt(n));
    }

    /// <summary>
    /// Routes the edges given in the list according to the current
    /// EdgeRouter settings stored in the PolylineEdgeRouterCustomConfig
    /// </summary>
    private async Task RouteAffectedEdges(IEnumerable<IEdge> edges) {
      try {
        // route the affected edges
        edgeRouterConfig.ScopeItem = Scope.RouteAffectedEdges;

        // get the layout algorithm with current settings
        var layoutAlgorithm = GetLayoutAlgorithm();

        // create a layout executor with 0.5 seconds execution time and the affected edges
        var layoutExecutor = new LayoutExecutor(graphControl, fullGraph, layoutAlgorithm) {
          LayoutData = new EdgeRouterData { AffectedEdges = { Source = edges } },
          Duration = TimeSpan.FromSeconds(0.5),
          AnimateViewport = true,
          EasedAnimation = true,
          UpdateContentRect = true
        };

        await layoutExecutor.Start();
      } catch (Exception e) {
        MessageBox.Show(this, "Layout did not complete successfully.\n" + e.Message);
      }
    }

    /// <summary>
    /// Creates the default input mode for the GraphControl, a <see cref="GraphEditorInputMode" />.
    /// </summary>
    /// <returns>a new GraphEditorInputMode instance with added event listeners and demo-specific settings such as no labels</returns>
    protected virtual IInputMode CreateEditorInputMode() {
      // disable labels because they are not needed in this demo
      var mode = new GraphEditorInputMode { AllowEditLabel = false, AllowAddLabel = false };

      // add the required event listeners that are called when edges might need to be re-routed
      mode.CreateEdgeInputMode.EdgeCreated += EdgeCreatedListener;
      mode.MoveInputMode.DragFinished += DragFinishedListenerMove;
      mode.HandleInputMode.DragFinished += DragFinishedListenerHandle;

      // make bend creation more important than moving of selected edges
      // this has the effect that dragging a selected edge (not its bends)
      // will create a new bend instead of moving all bends
      mode.CreateBendInputMode.Priority = mode.MoveInputMode.Priority - 1;

      // set the input mode
      graphControl.InputMode = mode;

      return mode;
    }

    /// <summary>
    /// The listener for a finished drag gesture, will add all affected edges and bends into a list
    /// and route the affected edges.
    /// </summary>
    private async void DragFinishedListenerHandle(object sender, InputModeEventArgs e) {
      var affectedEdges = new List<IEdge>();

      var graphSelection = graphControl.Selection;

      foreach (var node in graphSelection.SelectedNodes) {
        foreach (var edge in Graph.EdgesAt(node)) {
          affectedEdges.Add(edge);
        }
      }

      foreach (var bend in graphSelection.SelectedBends) {
        // add bend owners to the affected edges' list
        affectedEdges.Add(bend.Owner);
      }

      // route the affected edges
      await RouteAffectedEdges(affectedEdges);
    }

    /// <summary>
    /// Initializes the graph instance setting default styles,
    /// load the sample graph and route its edges.
    /// </summary>
    protected virtual void InitializeGraph() {
      // setting styles for maze nodes
      Graph.NodeDefaults.Style =
        new ShapeNodeStyle { Pen = null, Brush = new SolidColorBrush(Color.FromRgb(0x24, 0x22, 0x65)) };

      // add maze nodes to graph and store in a list
      graphControl.GraphMLIOHandler.Read(Graph, "Resources/mazeOnly.graphml");
      var mazeNodes = Graph.Nodes.ToList();

      // update styles for normal nodes
      DemoStyles.InitDemoStyles(Graph, nodeTheme: Themes.Palette31, groupTheme: Themes.Palette31, edgeTheme: Themes.Palette31);
      graphControl.GraphMLIOHandler.ClearGraphBeforeRead = false;
      graphControl.GraphMLIOHandler.Read(Graph, "Resources/normalNodesOnly.graphml");

      // store the full graph to use for layout configuration
      fullGraph = Graph;

      // add the visual of the maze to the graph
      foreach (var node in mazeNodes) {
        graphControl.BackgroundGroup.AddChild(node, CanvasObjectDescriptors.AlwaysDirtyLookup);
      }

      // route the edges according to the configured polylineEdgeRouter
      Graph.ApplyLayout(GetLayoutAlgorithm());

      // remove the maze after successfully applying the layout for the first time
      var filteredGraph = new FilteredGraphWrapper(
        Graph,
        // if the node has a tag, its a maze and needs to be removed
        node => node.Tag == null
      );

      // set the filtered graph without mazes
      Graph = filteredGraph;

      // enable undo engine and clear for first start
      Graph.SetUndoEngineEnabled(true);
      Graph.GetUndoEngine().Clear();
    }

    /// <summary>
    /// Returns the edgeRouter as the layout algorithm to use with the current config
    /// </summary>
    private EdgeRouter GetLayoutAlgorithm() {
      return edgeRouterConfig.CreateConfiguredLayout(graphControl);
    }

    /// <summary>
    /// Routes all edges in the graph by calling RouteAffectedEdges with a list of all edges
    /// </summary>
    private async Task RouteAllEdges() {
      await RouteAffectedEdges(Graph.Edges.ToList());
    }

    /// <summary>
    /// Apply the new graph settings by routing all edges
    /// </summary>
    private async void ApplyButtonClick(object sender, RoutedEventArgs e) {
      await RouteAllEdges();
    }

    /// <summary>
    /// Reset the settings by creating a new PolylineEdgeRouterCustomConfig object and assigning it newly
    /// </summary>
    private async void ResetButtonClick(object sender, RoutedEventArgs e) {
      edgeRouterConfig = new PolylineEdgeRouterCustomConfig();
      Editor.Configuration = edgeRouterConfig;
      await RouteAllEdges();
    }

    /// <summary>
    /// Returns the GraphControl instance used in the form.
    /// </summary>
    public GraphControl GraphControl {
      get { return graphControl; }
    }

    /// <summary>
    /// Gets the currently registered IGraph instance from the GraphControl.
    /// </summary>
    public IGraph Graph {
      get { return GraphControl.Graph; }
      set { GraphControl.Graph = value; }
    }
  }
}
