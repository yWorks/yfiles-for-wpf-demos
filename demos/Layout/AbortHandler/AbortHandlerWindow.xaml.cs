/****************************************************************************
 ** 
 ** This demo file is part of yFiles WPF 3.2.
 ** Copyright (c) 2000-2019 by yWorks GmbH, Vor dem Kreuzberg 28,
 ** 72070 Tuebingen, Germany. All rights reserved.
 ** 
 ** yFiles demo files exhibit yFiles WPF functionalities. Any redistribution
 ** of demo files in source code or binary form, with or without
 ** modification, is not permitted.
 ** 
 ** Owners of a valid software license for a yFiles WPF version that this
 ** demo is shipped with are allowed to use the demo source code as basis
 ** for their own yFiles WPF powered applications. Use of such programs is
 ** governed by the rights and conditions as set out in the yFiles WPF
 ** license agreement.
 ** 
 ** THIS SOFTWARE IS PROVIDED ''AS IS'' AND ANY EXPRESS OR IMPLIED
 ** WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF
 ** MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN
 ** NO EVENT SHALL yWorks BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
 ** SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED
 ** TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
 ** PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
 ** LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
 ** NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS
 ** SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 ** 
 ***************************************************************************/

using System;
using System.Linq;
using System.Windows;
using System.Windows.Media;
using System.Windows.Threading;
using yWorks.Controls;
using yWorks.Algorithms;
using yWorks.Layout;
using yWorks.Layout.Hierarchic;
using yWorks.Layout.Organic;
using yWorks.Layout.Orthogonal;
using yWorks.Controls.Input;
using yWorks.Geometry;
using yWorks.Graph;
using yWorks.Graph.Styles;

namespace Demo.yFiles.Layout.AbortHandler
{
  /// <summary>
  /// Shows how to use an <see cref="Demo.yFiles.Layout.AbortHandler"/>
  /// to stop or cancel running layout algorithms.
  /// </summary>
  /// <remarks>
  /// This demo uses a <see cref="LayoutExtensions.MorphLayout"/> method to run the layout in a background 
  /// thread and register the <see cref="Demo.yFiles.Layout.AbortHandler"/> which both are prerequisites
  /// to abort a running layout algorithm.
  /// </remarks>
  public partial class AbortHandlerWindow
  {
    private bool layoutRunning;

    private ILayoutAlgorithm layout;
    private LayoutData layoutData;
    private yWorks.Algorithms.AbortHandler abortHandler;

    /// <summary>
    /// Automatically generated by Visual Studio.
    /// Wires up the UI components and adds a 
    /// <see cref="GraphControl"/> to the form.
    /// </summary>
    public AbortHandlerWindow() {
      InitializeComponent();
    }

    /// <summary>
    /// Initializes this demo.
    /// </summary>
    /// <seealso cref="InitializeGraph"/>
    protected virtual void OnLoaded(object source, EventArgs e) {
      // initialize the graph
      InitializeGraph();

      // initialize an input mode
      GraphControl.InputMode = new GraphEditorInputMode();

      GraphControl.FitGraphBounds();
    }

    /// <summary>
    /// Initializes the graph instance setting default styles
    /// and creating a sample graph.
    /// </summary>
    protected virtual void InitializeGraph() {
      // set the default node style and size
      GraphControl.Graph.NodeDefaults.Style = new ShinyPlateNodeStyle { Brush = Brushes.Orange };
      GraphControl.Graph.NodeDefaults.Size = new SizeD(60, 40);

      BuildGraph(GraphControl.Graph);

      // Enable undo support
      GraphControl.Graph.SetUndoEngineEnabled(true);
    }

    /// <summary>
    /// Creates a large random graph to give the layout algorithms something to chew.
    /// </summary>
    private static void BuildGraph(IGraph graph) {
      graph.Clear();
      // Create 400 nodes
      INode[] nodes = new INode[400];
      for (int i = 0; i < nodes.Length; i++) {
        nodes[i] = graph.CreateNode();
      }
      // Connect the nodes randomly
      Random random = new Random(0);
      for (int i = 0; i < nodes.Length; i++) {
        int edgeCount;
        if (random.Next(10) == 0) {
          edgeCount = 4 + random.Next(5);
        } else {
          edgeCount = random.Next(3);
        }
        for (int j = 0; j < edgeCount; j++) {
          graph.CreateEdge(nodes[i], nodes[random.Next(nodes.Length)]);
        }
      }
      
      // remove all components except the largest one
      var adapter = new YGraphAdapter(graph);
      NodeList[] components = GraphConnectivity.ConnectedComponents(adapter.YGraph);

      Array.Sort(components, (o1, o2) => o2.Count - o1.Count);

      for (int i = components.Length - 1; i > 0; i--) {
        foreach (var node in components[i]) {
          graph.Remove(adapter.GetOriginalNode(node));
        }
      }

      // add labels
      int count = 0;
      foreach (var node in graph.Nodes) {
        graph.AddLabel(node, count++.ToString());
      }
     RandomizeGraph(graph);
    }
    
    /// <summary>
    /// Gets the <see cref="GraphControl"/> of this demo.
    /// </summary>
    public GraphControl GraphControl {
      get { return graphControl; }
    }

    private static void RandomizeGraph(IGraph graph) {
      // Remove all bends
      var bends = graph.Edges.SelectMany(e => e.Bends).ToList();
      foreach (var bend in bends) {
        graph.Remove(bend);
      }
      var r = new Random();
      // Place nodes in random locations
      foreach (var node in graph.Nodes) {
        graph.SetNodeCenter(node,
            new PointD(r.Next(1500), r.Next(1500)));
      }
    }

    /// <summary>
    /// Runs a new layout after the layout button was clicked.
    /// </summary>
    private async void OnLayoutButtonClicked(object sender, RoutedEventArgs e) {
      // avoid concurrent layouts
      if (layoutRunning) {
        return;
      }
      layoutRunning = true;

      // create a new layout with appropriate LayoutData and AbortHandler
      CreateLayout();

      // setup the AbortHandler and the AbortDialog
      double stopDurationSeconds;
      if (double.TryParse(stopDuration.Text.Trim(), out stopDurationSeconds) && stopDurationSeconds > 0) {
        abortHandler.StopDuration = TimeSpan.FromSeconds(stopDurationSeconds);
      }

      double cancelDurationSeconds;
      if (double.TryParse(cancelDuration.Text.Trim(), out cancelDurationSeconds) && cancelDurationSeconds > 0) {
        abortHandler.CancelDuration = TimeSpan.FromSeconds(cancelDurationSeconds);
      }

      var abortDialog = new AbortDialog {AbortHandler = abortHandler, Owner = this};

      // see if we are doing a quick layout - and if it takes more than a few seconds, we open the dialog to 
      // enable the user to stop or cancel the execution 
      var showDialogTimer = new DispatcherTimer(DispatcherPriority.Normal, Dispatcher)
      {
        Interval = TimeSpan.FromSeconds(2)
      };

      showDialogTimer.Tick += delegate {
        // it could be that the layout is already done or already cancelled by the timer - so check whether we still 
        // need to open the dialog
        if (layoutRunning && abortHandler.TimeToCancel().TotalMilliseconds >= 0) {
          // open the abort dialog
          abortDialog.Show();
        }
        // we only want to let it go off once - so stop the timer
        showDialogTimer.Stop();
      };

      // kick-off the timer
      showDialogTimer.Start();

      // start the layout
      try {
        await graphControl.MorphLayout(layout, TimeSpan.FromSeconds(1), layoutData);
      } catch (OperationCanceledException) {
        // Layout has been canceled
      }

      // after the layout has been finished (or aborted): close the dialog
      if (abortDialog.IsVisible) {
        abortDialog.Close();
      }
      layoutRunning = false;
    }

    /// <summary>
    /// Creates the layout with an appropriate layout data which is selected by the layout combo box.
    /// </summary>
    private void CreateLayout() {
      switch (layoutComboBox.SelectedIndex) {
        default:
        case 0:
          layout = new HierarchicLayout();
          var hierarchicLayoutData = new HierarchicLayoutData();
          layoutData = hierarchicLayoutData;
          abortHandler = hierarchicLayoutData.AbortHandler;
          break;
        case 1:
          layout = new OrganicLayout
          {
            QualityTimeRatio = 1.0,
            MaximumDuration = 1200000,
            MultiThreadingAllowed = true
          };
          var organicLayoutData = new OrganicLayoutData();
          layoutData = organicLayoutData;
          abortHandler = organicLayoutData.AbortHandler;
          break;
        case 2:
          layout = new OrthogonalLayout {CrossingReduction = true};
          var orthogonalLayoutData = new OrthogonalLayoutData();
          layoutData = orthogonalLayoutData;
          abortHandler = orthogonalLayoutData.AbortHandler;
          break;
      }
    }
  }
}
